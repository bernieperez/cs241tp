<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_04) on Thu Feb 26 10:16:23 CET 2009 -->
<TITLE>
HandleVector
</TITLE>

<META NAME="date" CONTENT="2009-02-26">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../VersantStylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="HandleVector";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../com/versant/fund/HandleEnumeration.html" title="interface in com.versant.fund"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../com/versant/fund/NewSessionCapability.html" title="class in com.versant.fund"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?com/versant/fund/HandleVector.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="HandleVector.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
com.versant.fund</FONT>
<BR>
Class HandleVector</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by ">java.util.AbstractCollection&lt;E&gt;
      <IMG SRC="../../../resources/inherit.gif" ALT="extended by ">java.util.AbstractList&lt;E&gt;
          <IMG SRC="../../../resources/inherit.gif" ALT="extended by ">java.util.Vector
              <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>com.versant.fund.HandleVector</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD>java.io.Serializable, java.lang.Cloneable, java.lang.Iterable, java.util.Collection, java.util.List, java.util.RandomAccess</DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>HandleVector</B><DT>extends java.util.Vector</DL>
</PRE>

<P>
A homogenous vector for <code>Handle</code> objects only. It houses
 methods for database group operations like 
 <code>groupReadObjects()</code> and vector manipulation
 methods like <code>diffWith()</code>.<p>
 Since methods in the <code>java.util.Vector</code> class are mostly
 final, <code>HandleVector</code> defines its own methods which are 
 analogs of the Vector methods, replacing "Element" with "Handle" in
 method names and argument lists.<p>

 The HandleVector methods involving database functionality, such as, 
 groupReadObjects, groupWriteObjects etc. require the HandleVector to be 
 associated with a session. A new HandleVector instance can only be obtained
 by invoking the <code>session.newHandleVector</code>methods.
<P>

<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/versant/fund/Session.html#newHandleVector()"><CODE>Session.newHandleVector()</CODE></A>, 
<A HREF="../../../com/versant/fund/Session.html#newHandleVector(com.versant.fund.Handle[])"><CODE>Session.newHandleVector(Handle[])</CODE></A>, 
<A HREF="../../../com/versant/fund/Session.html#newHandleVector(com.versant.fund.HandleEnumeration)"><CODE>Session.newHandleVector(HandleEnumeration)</CODE></A>, 
<A HREF="../../../serialized-form.html#com.versant.fund.HandleVector">Serialized Form</A></DL>
<HR>

<P>

<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/versant/fund/HandleVector.html#addHandle(com.versant.fund.Handle)">addHandle</A></B>(<A HREF="../../../com/versant/fund/Handle.html" title="interface in com.versant.fund">Handle</A>&nbsp;h)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds the specified handle as the last element of this vector.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/versant/fund/Handle.html" title="interface in com.versant.fund">Handle</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/versant/fund/HandleVector.html#asArray()">asArray</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an array of the <code>Handles</code> in the vector.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/versant/fund/HandleEnumeration.html" title="interface in com.versant.fund">HandleEnumeration</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/versant/fund/HandleVector.html#asHandleEnumeration()">asHandleEnumeration</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an enumeration of the handles in this vector.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/versant/fund/HandleVector.html#asString()">asString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a String of the contents of this <code>HandleVector</code></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/versant/fund/HandleVector.html#checkpointCommit()">checkpointCommit</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Performs a checkpoint commit all new and dirty objects in this 
 handle vector.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/versant/fund/HandleVector.html#checkTimestamps()">checkTimestamps</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determines whether database source objects have changed since the 
 copies in this handle <code>vector</code> have been read into the 
 object cache.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/versant/fund/HandleVector.html#commitAndRetain()">commitAndRetain</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Commits all new and dirty objects in this handle vector.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/versant/fund/HandleVector.html" title="class in com.versant.fund">HandleVector</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/versant/fund/HandleVector.html#concatWith(com.versant.fund.HandleVector)">concatWith</A></B>(<A HREF="../../../com/versant/fund/HandleVector.html" title="class in com.versant.fund">HandleVector</A>&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a new instance of <code>HandleVector</code> that is the 
 concatenation of the contents of this instance and the 
 <code>vector</code> specified as <code>v</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/versant/fund/HandleVector.html#containsHandle(com.versant.fund.Handle)">containsHandle</A></B>(<A HREF="../../../com/versant/fund/Handle.html" title="interface in com.versant.fund">Handle</A>&nbsp;h)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if this <code>vector</code> contains the
 specified handle and otherwise returns <code>false</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/versant/fund/HandleVector.html#copyIntoArray(com.versant.fund.Handle[])">copyIntoArray</A></B>(<A HREF="../../../com/versant/fund/Handle.html" title="interface in com.versant.fund">Handle</A>[]&nbsp;anArray)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Replaces the contents of the array specified as 
 <code>anArray[]</code> with the contents of this vector.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/versant/fund/HandleVector.html#copyObjects(java.lang.String, java.lang.String)">copyObjects</A></B>(java.lang.String&nbsp;sourcedb,
            java.lang.String&nbsp;targetdb)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Without changing object identifiers, copies the objects in this 
 <code>vector</code> from one database to another.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/versant/fund/HandleVector.html" title="class in com.versant.fund">HandleVector</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/versant/fund/HandleVector.html#diffWith(com.versant.fund.HandleVector)">diffWith</A></B>(<A HREF="../../../com/versant/fund/HandleVector.html" title="class in com.versant.fund">HandleVector</A>&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a new <code>vector</code> that is the difference of this 
 <code>vector</code> and the <code>vector</code> specified as 
 <code>v</code> and removes empty and duplicate objects from the 
 result.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/versant/fund/HandleVector.html#downgradeLocksTo(int)">downgradeLocksTo</A></B>(int&nbsp;lockmode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Downgrades or releases locks on the objects in this 
 <code>vector</code> without flushing the objects from the 
 application cache.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/versant/fund/Handle.html" title="interface in com.versant.fund">Handle</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/versant/fund/HandleVector.html#firstHandle()">firstHandle</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the first handle in this vector.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/versant/fund/HandleVector.html" title="class in com.versant.fund">HandleVector</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/versant/fund/HandleVector.html#getClosure(java.lang.String, int, boolean, int)">getClosure</A></B>(java.lang.String&nbsp;dbName,
           int&nbsp;levels,
           boolean&nbsp;toPin,
           int&nbsp;lockmode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get closure of objects.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/versant/fund/HandleVector.html#groupDeleteObjects(java.lang.String)">groupDeleteObjects</A></B>(java.lang.String&nbsp;dbname)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deletes the objects in this <code>vector</code> from the database 
 <code>db</code> and returns the objects not deleted to an instance 
 variable of <code>VException</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/versant/fund/HandleVector.html#groupReadObjects(java.lang.String, int, int)">groupReadObjects</A></B>(java.lang.String&nbsp;dbname,
                 int&nbsp;option,
                 int&nbsp;lockmode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reads into memory the objects in this <code>vector</code> located 
 in the database <code>dbName</code>, optionally pins the objects in
 memory, and optionally places locks on the objects.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/versant/fund/HandleVector.html#groupWriteClustered(java.lang.String, com.versant.fund.Handle, int)">groupWriteClustered</A></B>(java.lang.String&nbsp;dbname,
                    <A HREF="../../../com/versant/fund/Handle.html" title="interface in com.versant.fund">Handle</A>&nbsp;parent_object,
                    int&nbsp;options)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Writes a group of objects to a database and places the objects near
 an existing parent object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/versant/fund/HandleVector.html#groupWriteIsolated(java.lang.String, int)">groupWriteIsolated</A></B>(java.lang.String&nbsp;dbname,
                   int&nbsp;options)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Writes a group of objects to a database and isolate the objects on 
 their own page.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/versant/fund/HandleVector.html#groupWriteObjects(int)">groupWriteObjects</A></B>(int&nbsp;option)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Writes objects as a group.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/versant/fund/Handle.html" title="interface in com.versant.fund">Handle</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/versant/fund/HandleVector.html#handleAt(int)">handleAt</A></B>(int&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the handle at the position specified as <code>index.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/versant/fund/HandleEnumeration.html" title="interface in com.versant.fund">HandleEnumeration</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/versant/fund/HandleVector.html#handles()">handles</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a <code>HandleEnumeration</code> of the <code>Handles</code>
 in the vector.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/versant/fund/HandleVector.html#indexOfHandle(com.versant.fund.Handle)">indexOfHandle</A></B>(<A HREF="../../../com/versant/fund/Handle.html" title="interface in com.versant.fund">Handle</A>&nbsp;h)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Searches for the specified Handle, starting from the first 
 position and returns its index in the vector or -1 if it was not
 found.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/versant/fund/HandleVector.html#indexOfHandle(com.versant.fund.Handle, int)">indexOfHandle</A></B>(<A HREF="../../../com/versant/fund/Handle.html" title="interface in com.versant.fund">Handle</A>&nbsp;h,
              int&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Searches for the specified Handle, starting from the specified 
 position and returns its index in the vector.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/versant/fund/HandleVector.html#insertHandleAt(com.versant.fund.Handle, int)">insertHandleAt</A></B>(<A HREF="../../../com/versant/fund/Handle.html" title="interface in com.versant.fund">Handle</A>&nbsp;h,
               int&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Inserts the handle specified as <code>h</code> into this 
 <code>vector</code> at the position specified as <code>index</code>
 and shift all existing elements at position <code>index</code> or 
 greater upwards by one position.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/versant/fund/HandleVector.html" title="class in com.versant.fund">HandleVector</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/versant/fund/HandleVector.html#intersectWith(com.versant.fund.HandleVector)">intersectWith</A></B>(<A HREF="../../../com/versant/fund/HandleVector.html" title="class in com.versant.fund">HandleVector</A>&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a new <code>vector</code> that is the intersection of this 
 <code>vector</code> and the <code>vector</code> specified as 
 <code>v</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/versant/fund/Handle.html" title="interface in com.versant.fund">Handle</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/versant/fund/HandleVector.html#lastHandle()">lastHandle</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the last handle in this vector.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/versant/fund/HandleVector.html#lastIndexOfHandle(com.versant.fund.Handle)">lastIndexOfHandle</A></B>(<A HREF="../../../com/versant/fund/Handle.html" title="interface in com.versant.fund">Handle</A>&nbsp;h)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Searches backwards for the specified Handle, starting from the 
 last position in the vector and returns an index to it.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/versant/fund/HandleVector.html#lastIndexOfHandle(com.versant.fund.Handle, int)">lastIndexOfHandle</A></B>(<A HREF="../../../com/versant/fund/Handle.html" title="interface in com.versant.fund">Handle</A>&nbsp;h,
                  int&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Searches backwards for the specified Handle, starting from the last
 position in the vector and returns an index to it.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/versant/fund/HandleVector.html#migrateObjects(java.lang.String, java.lang.String)">migrateObjects</A></B>(java.lang.String&nbsp;sourcedb,
               java.lang.String&nbsp;targetdb)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Physically moves the objects in this <code>vector</code> from 
 database <code>sourcedb</code> to database <code>targetdb</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/versant/fund/HandleVector.html#refreshObjects(java.lang.String, int)">refreshObjects</A></B>(java.lang.String&nbsp;dbname,
               int&nbsp;lockmode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Refresh object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/versant/fund/HandleVector.html#releaseObjects(int)">releaseObjects</A></B>(int&nbsp;option)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Immediately releases the memory space used by the objects in this
 vector.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/versant/fund/HandleVector.html#removeAllHandles()">removeAllHandles</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes all <code>Handles</code> in the vector.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/versant/fund/HandleVector.html#removeHandle(com.versant.fund.Handle)">removeHandle</A></B>(<A HREF="../../../com/versant/fund/Handle.html" title="interface in com.versant.fund">Handle</A>&nbsp;h)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes from this <code>vector</code> the first occurrence of the 
 handle specified as <code>h</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/versant/fund/HandleVector.html#removeHandleAt(int)">removeHandleAt</A></B>(int&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes the handle at the position specified at the 
 <code>index</code> from this <code>vector</code> and moves all 
 handles at positions greater than <code>index</code> downwards by 
 one position.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/versant/fund/HandleVector.html#rollbackAndRetain()">rollbackAndRetain</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rollbacks all new and dirty objects in this handle vector.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/versant/fund/HandleVector.html#setHandleAt(com.versant.fund.Handle, int)">setHandleAt</A></B>(<A HREF="../../../com/versant/fund/Handle.html" title="interface in com.versant.fund">Handle</A>&nbsp;h,
            int&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the handle at the specified index to be the specified handle 
 and discards the previous handle at that position.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/versant/fund/HandleVector.html#setObjectsDatabase(java.lang.String)">setObjectsDatabase</A></B>(java.lang.String&nbsp;dbName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies the database from which persistent objects in this vector
 are to be fetched.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/versant/fund/HandleVector.html" title="class in com.versant.fund">HandleVector</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/versant/fund/HandleVector.html#unionWith(com.versant.fund.HandleVector)">unionWith</A></B>(<A HREF="../../../com/versant/fund/HandleVector.html" title="class in com.versant.fund">HandleVector</A>&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a new <code>vector</code> that is the union of this 
 <code>vector</code> and the <code>vector</code> specified as 
 <code>v</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/versant/fund/HandleVector.html#zapObjects()">zapObjects</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Releases the objects in this <code>vector</code> from memory and 
 makes their cached object descriptors available for re-use.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.util.Vector"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.util.Vector</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>add, add, addAll, addAll, addElement, capacity, clear, clone, contains, containsAll, copyInto, elementAt, elements, ensureCapacity, equals, firstElement, get, hashCode, indexOf, indexOf, insertElementAt, isEmpty, lastElement, lastIndexOf, lastIndexOf, remove, remove, removeAll, removeAllElements, removeElement, removeElementAt, retainAll, set, setElementAt, setSize, size, subList, toArray, toArray, toString, trimToSize</CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.util.AbstractList"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.util.AbstractList</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>iterator, listIterator, listIterator</CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>getClass, notify, notifyAll, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.util.List"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from interface java.util.List</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>iterator, listIterator, listIterator</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="copyIntoArray(com.versant.fund.Handle[])"><!-- --></A><H3>
copyIntoArray</H3>
<PRE>
public final void <B>copyIntoArray</B>(<A HREF="../../../com/versant/fund/Handle.html" title="interface in com.versant.fund">Handle</A>[]&nbsp;anArray)</PRE>
<DL>
<DD>Replaces the contents of the array specified as 
 <code>anArray[]</code> with the contents of this vector.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>anArray</CODE> - The array of handles to copy the 
                                        contents of this <code>vector</code> into.<p></DL>
</DD>
</DL>
<HR>

<A NAME="addHandle(com.versant.fund.Handle)"><!-- --></A><H3>
addHandle</H3>
<PRE>
public final void <B>addHandle</B>(<A HREF="../../../com/versant/fund/Handle.html" title="interface in com.versant.fund">Handle</A>&nbsp;h)</PRE>
<DL>
<DD>Adds the specified handle as the last element of this vector.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>h</CODE> - The <code>Handle</code> to add.<p></DL>
</DD>
</DL>
<HR>

<A NAME="insertHandleAt(com.versant.fund.Handle, int)"><!-- --></A><H3>
insertHandleAt</H3>
<PRE>
public final void <B>insertHandleAt</B>(<A HREF="../../../com/versant/fund/Handle.html" title="interface in com.versant.fund">Handle</A>&nbsp;h,
                                 int&nbsp;index)</PRE>
<DL>
<DD>Inserts the handle specified as <code>h</code> into this 
 <code>vector</code> at the position specified as <code>index</code>
 and shift all existing elements at position <code>index</code> or 
 greater upwards by one position.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>h</CODE> - The <code>Handle</code> to insert.<DD><CODE>index</CODE> - The location in the <code>vector</code> 
 to insert the handle. 
 If the specified position is invalid, you get the exception 
 <code>ArrayIndexOutOfBoundsException</code>.<p></DL>
</DD>
</DL>
<HR>

<A NAME="removeAllHandles()"><!-- --></A><H3>
removeAllHandles</H3>
<PRE>
public final void <B>removeAllHandles</B>()</PRE>
<DL>
<DD>Removes all <code>Handles</code> in the vector. The vector becomes empty. <p>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="removeHandle(com.versant.fund.Handle)"><!-- --></A><H3>
removeHandle</H3>
<PRE>
public final boolean <B>removeHandle</B>(<A HREF="../../../com/versant/fund/Handle.html" title="interface in com.versant.fund">Handle</A>&nbsp;h)</PRE>
<DL>
<DD>Removes from this <code>vector</code> the first occurrence of the 
 handle specified as <code>h</code>.
 <p>
 Returns <code>true</code> if the handle was actually removed and 
 otherwise returns
 <code>false</code>.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>h</CODE> - The <code>Handle</code> to remove from 
 this vector.</DL>
</DD>
</DL>
<HR>

<A NAME="removeHandleAt(int)"><!-- --></A><H3>
removeHandleAt</H3>
<PRE>
public final void <B>removeHandleAt</B>(int&nbsp;index)</PRE>
<DL>
<DD>Removes the handle at the position specified at the 
 <code>index</code> from this <code>vector</code> and moves all 
 handles at positions greater than <code>index</code> downwards by 
 one position.
 <p>
 If the position <code>index</code> is invalid, the exception 
 <code>ArrayIndexOutOfBoundsException</code> is raised.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>index</CODE> - The position of the handle to remove 
 from this vector.</DL>
</DD>
</DL>
<HR>

<A NAME="setHandleAt(com.versant.fund.Handle, int)"><!-- --></A><H3>
setHandleAt</H3>
<PRE>
public final void <B>setHandleAt</B>(<A HREF="../../../com/versant/fund/Handle.html" title="interface in com.versant.fund">Handle</A>&nbsp;h,
                              int&nbsp;index)</PRE>
<DL>
<DD>Sets the handle at the specified index to be the specified handle 
 and discards the previous handle at that position.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>h</CODE> - The handle.<DD><CODE>index</CODE> - The specified index
<DT><B>Throws:</B>
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if the index is invalid.</DL>
</DD>
</DL>
<HR>

<A NAME="containsHandle(com.versant.fund.Handle)"><!-- --></A><H3>
containsHandle</H3>
<PRE>
public final boolean <B>containsHandle</B>(<A HREF="../../../com/versant/fund/Handle.html" title="interface in com.versant.fund">Handle</A>&nbsp;h)</PRE>
<DL>
<DD>Returns <code>true</code> if this <code>vector</code> contains the
 specified handle and otherwise returns <code>false</code>.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>h</CODE> - The <code>Handle</code> to find in 
 <code>this</code> <code>vector</code>.<p></DL>
</DD>
</DL>
<HR>

<A NAME="handleAt(int)"><!-- --></A><H3>
handleAt</H3>
<PRE>
public final <A HREF="../../../com/versant/fund/Handle.html" title="interface in com.versant.fund">Handle</A> <B>handleAt</B>(int&nbsp;index)</PRE>
<DL>
<DD>Returns the handle at the position specified as <code>index.</code>
 <p>
 If you specify an invalid index, you get the exception 
 <code>ArrayIndexOutOfBoundsException</code>. If the element at the 
 specified position is not an instance of <code>Handle</code>, you 
 get the exception <code>EVJ_NOT_HANDLE_OBJ</code>.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>index</CODE> - The location of the <code>handle</code>.</DL>
</DD>
</DL>
<HR>

<A NAME="firstHandle()"><!-- --></A><H3>
firstHandle</H3>
<PRE>
public final <A HREF="../../../com/versant/fund/Handle.html" title="interface in com.versant.fund">Handle</A> <B>firstHandle</B>()</PRE>
<DL>
<DD>Returns the first handle in this vector.
 <p>
 If the <code>vector</code> is empty, the exception 
 <code>NoSuchElementException</code> is raised. If the first element
 in the <code>vector</code> is not an instance of <code>Handle</code>,
 the exception <code>EVJ_NOT_HANDLE_OBJ</code> is thrown. To check 
 error numbers, you can use <code>getErrno()</code> on 
 <code>VException</code>.<p>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lastHandle()"><!-- --></A><H3>
lastHandle</H3>
<PRE>
public final <A HREF="../../../com/versant/fund/Handle.html" title="interface in com.versant.fund">Handle</A> <B>lastHandle</B>()</PRE>
<DL>
<DD>Returns the last handle in this vector.
 <p>
 If the <code>vector</code> is empty, you get exception 
 <code>NoSuchElementException</code>. If the last element is not an
 instance of <code>Handle</code>, you get a <code>VException</code> with
 the error constant <code>EVJ_NOT_HANDLE_OBJ</code>.<p>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="indexOfHandle(com.versant.fund.Handle)"><!-- --></A><H3>
indexOfHandle</H3>
<PRE>
public final int <B>indexOfHandle</B>(<A HREF="../../../com/versant/fund/Handle.html" title="interface in com.versant.fund">Handle</A>&nbsp;h)</PRE>
<DL>
<DD>Searches for the specified Handle, starting from the first 
 position and returns its index in the vector or -1 if it was not
 found.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>h</CODE> - The <code>Handle</code> being checked for<p></DL>
</DD>
</DL>
<HR>

<A NAME="indexOfHandle(com.versant.fund.Handle, int)"><!-- --></A><H3>
indexOfHandle</H3>
<PRE>
public final int <B>indexOfHandle</B>(<A HREF="../../../com/versant/fund/Handle.html" title="interface in com.versant.fund">Handle</A>&nbsp;h,
                               int&nbsp;index)</PRE>
<DL>
<DD>Searches for the specified Handle, starting from the specified 
 position and returns its index in the vector.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>h</CODE> - The Handle being checked for.<DD><CODE>index</CODE> - The index in the vector from where to 
 start searching.
 Returns the index of the Handle in the vector, or -1 if it was not
 found.<p></DL>
</DD>
</DL>
<HR>

<A NAME="lastIndexOfHandle(com.versant.fund.Handle)"><!-- --></A><H3>
lastIndexOfHandle</H3>
<PRE>
public final int <B>lastIndexOfHandle</B>(<A HREF="../../../com/versant/fund/Handle.html" title="interface in com.versant.fund">Handle</A>&nbsp;h)</PRE>
<DL>
<DD>Searches backwards for the specified Handle, starting from the 
 last position in the vector and returns an index to it.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>h</CODE> - The Handle being checked for
 Returns the index of the Handle in the vector, or -1 if it was not 
 found.<p></DL>
</DD>
</DL>
<HR>

<A NAME="lastIndexOfHandle(com.versant.fund.Handle, int)"><!-- --></A><H3>
lastIndexOfHandle</H3>
<PRE>
public final int <B>lastIndexOfHandle</B>(<A HREF="../../../com/versant/fund/Handle.html" title="interface in com.versant.fund">Handle</A>&nbsp;h,
                                   int&nbsp;index)</PRE>
<DL>
<DD>Searches backwards for the specified Handle, starting from the last
 position in the vector and returns an index to it.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>h</CODE> - The Handle being checked for.<DD><CODE>index</CODE> - The index in the vector from where to 
 start searching.
 Returns the index of the Handle in the vector, or -1 if it was not 
 found.<p></DL>
</DD>
</DL>
<HR>

<A NAME="handles()"><!-- --></A><H3>
handles</H3>
<PRE>
public final <A HREF="../../../com/versant/fund/HandleEnumeration.html" title="interface in com.versant.fund">HandleEnumeration</A> <B>handles</B>()</PRE>
<DL>
<DD>Returns a <code>HandleEnumeration</code> of the <code>Handles</code>
 in the vector.<p>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="asHandleEnumeration()"><!-- --></A><H3>
asHandleEnumeration</H3>
<PRE>
public final <A HREF="../../../com/versant/fund/HandleEnumeration.html" title="interface in com.versant.fund">HandleEnumeration</A> <B>asHandleEnumeration</B>()</PRE>
<DL>
<DD>Returns an enumeration of the handles in this vector.
 <p>
 Once you have an instance of <code>HandleEnumeration</code>, you 
 can then use methods in <code>HandleEnumeration</code> to enumerate
 the handles sequentially.<p>
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/versant/fund/HandleEnumeration.html#hasMoreHandles()"><CODE>HandleEnumeration.hasMoreHandles()</CODE></A>, 
<CODE>Enumeration.hasMoreElements()</CODE>, 
<A HREF="../../../com/versant/fund/HandleEnumeration.html#nextHandle()"><CODE>HandleEnumeration.nextHandle()</CODE></A>, 
<CODE>Enumeration.nextElement()</CODE>, 
<A HREF="../../../com/versant/fund/HandleEnumeration.html#nextBatch()"><CODE>HandleEnumeration.nextBatch()</CODE></A>, 
<A HREF="../../../com/versant/fund/HandleEnumeration.html#asArray()"><CODE>HandleEnumeration.asArray()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="asArray()"><!-- --></A><H3>
asArray</H3>
<PRE>
public final <A HREF="../../../com/versant/fund/Handle.html" title="interface in com.versant.fund">Handle</A>[] <B>asArray</B>()</PRE>
<DL>
<DD>Returns an array of the <code>Handles</code> in the vector.<p>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="asString()"><!-- --></A><H3>
asString</H3>
<PRE>
public final java.lang.String <B>asString</B>()</PRE>
<DL>
<DD>Returns a String of the contents of this <code>HandleVector</code>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="groupReadObjects(java.lang.String, int, int)"><!-- --></A><H3>
groupReadObjects</H3>
<PRE>
public void <B>groupReadObjects</B>(java.lang.String&nbsp;dbname,
                             int&nbsp;option,
                             int&nbsp;lockmode)</PRE>
<DL>
<DD>Reads into memory the objects in this <code>vector</code> located 
 in the database <code>dbName</code>, optionally pins the objects in
 memory, and optionally places locks on the objects.
 <p>
 If you pin objects, 
 you must later manually unpin them with <code>unpinObject()</code> 
 or release them with a commit, rollback, or undosavepoint.
 Pinning options are:
 <p>
 <ul>
 <li><code>0</code><p>
 Do not pin objects or release their locks. The default.
 <li><code>Constants.PIN_OBJECTS</code>
 Pin returned objects in memory.
 Later, you will need to manually unpin the objects using 
 <code>com.versant.fund.Handle.unpinObject()</code> or release them 
 be ending the transaction.
 <li><code>Constants.DOWNGRADE_LOCKS</code>
 Release locks immediately after objects have been read 
 into memory. Normally locks are kept until a transaction ends.
 Specify both <code>PIN_OBJECTS</code> and <code>DOWNGRADE_LOCKS</code> 
 to both pin and unlock the objects.
 </ul>
 <p>
 Alternatives for <code>lockmode</code> are:<p>
 <ul>
 <li><code>Constants.WLOCK</code>       : Write lock </li>
 <li><code>Constants.RIWLOCK</code> : Read/intention-write lock </li>
 <li><code>Constants.IWLOCK</code>      : Intention-write lock </li>
 <li><code>Constants.ULOCK</code>       : Update lock </li>
 <li><code>Constants.RLOCK</code>       : Read lock </li>
 <li><code>Constants.IRLOCK</code>      : Intention-read lock </li>
 <li><code>Constants.NOLOCK</code>      : No lock </li>
 </ul>
 All objects to be read into memory must be from the same database.<p>
 For a complete description of lock modes, see the <i>VERSANT 
 Database 
 Fundamentals</i>.<p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dbname</CODE> - The name of database with the objects 
                                        to be read into memory.<DD><CODE>option</CODE> - Pinning options.<DD><CODE>lockmode</CODE> - Type of lock to place on the returned
        instances, which also has the effect of placing a similar intention
        lock on the class objects for the returned instances.<DT><B>See Also:</B><DD><A HREF="../../../com/versant/fund/Handle.html#unpinObject()"><CODE>Handle.unpinObject()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="groupWriteObjects(int)"><!-- --></A><H3>
groupWriteObjects</H3>
<PRE>
public void <B>groupWriteObjects</B>(int&nbsp;option)</PRE>
<DL>
<DD>Writes objects as a group.
 <p>
 Alternatives for 
 <code>options</code> are:
 <p>
 <ul>
 <li><code>0</code><p>
        <code>Null</code> option.
 <li>Constants.FREE_OBJECTS</code>
        Release the objects in this <code>vector</code> from 
        memory if they are not pinned in another pin region. Handles to the
        specified objects remain valid.
 <li><code>Constants.CLEAN_CODS</code>
        Immediately clear the cached object descriptor table of 
        all entries except those for class objects, dirty objects, and 
        pinned objects.
 </ul>
 This method writes the persistent objects in this <code>vector</code>
 to their source database, marks the specified objects as clean, and
 optionally releases the specified objects from memory or releases 
 the cached object descriptors for the objects from memory.<p>
 All objects specified in this <code>vector</code> must be from the 
 same database.<p>
 When a cached object descriptor is released from the cached object
 descriptor table, the corresponding object is released from memory.<p>
 Releasing cached object descriptors invalidates handles to the 
 corresponding objects.<p>
 You should not use this option if a dirty object contains a handle
 to an unpinned object (i.e., an object whose cached object 
 descriptor has been zapped), because at commit time VERSANT is not 
 able to find the cached object descriptor for the target object. 
 Similarly, after clearing cached object descriptors, you should not
 dirty an object containing a handle to an object whose cached 
 object descriptor has been cleared, as this could result in a 
 corrupted handle.<p>
 If you do clear the cached object descriptor for an object that is
 the target of a handle in a dirty object, you get the error 
 <code>OM_COD_ALREADY_FREED</code> at commit time because VERSANT is
 not able to find the cached object descriptor for the target 
 object. However, if you continue in the same transaction after 
 clearing cached object descriptors, VERSANT may reuse a previously 
 zapped cached object descriptor, in which case you will corrupt 
 the handle without getting an error.<p>
 Releasing cached object descriptors frees space in the cached 
 object descriptor table for reuse, which is useful if you need to 
 reclaim space in the application process heap during a session that
 references a very large number (say, a million or more) of objects.<p>
 Clearing the cached object descriptor table does not affect the 
 database state of an object.<p>
 To clear the cached object descriptor table, you can also use 
 <code>zapObjects()</code>.
 The <code>CLEAN_CODS</code> option can be used in the following 
 functions: 
 <code>groupWriteObjects()</code>. To simply clear cache memory, 
 you can use <code>releaseObject()</code>, <code>releaseObjects()</code>, 
 <code>unpinObject()</code>, or <code>groupWriteObjects()</code>.<p>
 Because <code>CLEAN_CODS</code> invalidates handles, it should be 
 used with care.<p>
 This method should be used only for memory management, because the 
 objects written to disk are still part of the current transaction 
 and are still subject to a rollback of the transaction.<p>
 If you write an object to disk and then downgrade its lock, you 
 will get unpredictable results if your transaction rolls back. If
 you want to save changes and release locks, use <code>commit()</code>
 instead of <code>groupWriteObjects()</code>.<p>
 Handles in this vector should not be re-used after invocation of 
 this method.<p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>option</CODE> - Pinning options.<DT><B>See Also:</B><DD><A HREF="../../../com/versant/fund/Handle.html#refreshObject(int)"><CODE>Handle.refreshObject(int)</CODE></A>, 
<A HREF="../../../com/versant/fund/HandleVector.html#refreshObjects(java.lang.String, int)"><CODE>HandleVector.refreshObjects(String,int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="groupWriteClustered(java.lang.String, com.versant.fund.Handle, int)"><!-- --></A><H3>
groupWriteClustered</H3>
<PRE>
public void <B>groupWriteClustered</B>(java.lang.String&nbsp;dbname,
                                <A HREF="../../../com/versant/fund/Handle.html" title="interface in com.versant.fund">Handle</A>&nbsp;parent_object,
                                int&nbsp;options)</PRE>
<DL>
<DD>Writes a group of objects to a database and places the objects near
 an existing parent object. The parent object should belong to the 
 same storage file as the child objects. This will happen if:
 <p>
 The parent object is of the same class as the child objects, or<p>
 The parent object is of a different class, the classes have been 
 clustered together using the cluster method in the 
 <code>Session</code> class hierarchy.<p>
 If the parent object is newly created, you must explicitly write 
 it out before using it in a group write clustered operation.  
 VERSANT attempts to place the child objects on the same page as 
 the parent object. If the page does not have enough space,  some 
 objects will be written to a new page.  If using the 
 <code>Constants.CLEAN_CODS</code> option, the cached object 
 descriptor table of all entries except those for class objects, 
 dirty objects, and pinned objects are immediately cleared. When a 
 cached object descriptor is released from the cached object 
 descriptor table, the corresponding object is released from memory.
 Releasing cached object descriptors invalidates handles to the 
 corresponding objects.<p>
 You should not use this option if a dirty object contains a handle 
 to an unpinned object (i.e., an object whose cached object 
 descriptor has been zapped), because at commit time VERSANT is not 
 able to find the cached object descriptor for the target object. 
 Similarly, after clearing cached object descriptors, you should not
 dirty an object containing a handle to an object whose cached 
 object descriptor has been cleared, as this could result in a 
 corrupted handle.<p>
 If you do clear the cached object descriptor for an object that is
 the target of a handle in a dirty object, you get the VERSANT error
 <code>OM_COD_ALREADY_FREED</code> at commit time because VERSANT is
 not able to find the cached object descriptor for the target object. 
 However, if you continue in the same transaction after clearing 
 cached object descriptors, VERSANT may reuse a previously zapped 
 cached object descriptor, in which case you will corrupt the handle
 without getting an error.  Releasing cached object descriptors 
 frees space in the cached object descriptor table for reuse, which
 is useful if you need to reclaim space in the application process 
 heap during a session that references a very large number (say, 
 a million or more) of objects.<p>
 Clearing the cached object descriptor table does not affect the 
 database state of an object.<p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dbname</CODE> - Name of the database to write the 
                                        objects to.<DD><CODE>parent_object</CODE> - Handle to the parent object,
                                                which is used to determine a storage location 
                                                for the objects that are written.<DD><CODE>options</CODE> - The valid options are:
 <ul>
 <li>0 : 
        No options specified</li>
 <li><code>Constants.FREE_OBJECTS</code> : 
        Release objects in the array from the VERSANT front-end object cache </li>
 <li><code>Constants.CLEAN_CODS</code> : 
        Release the cached object descriptors of objects in the array 
        from the VERSANT front-end object cache.</li>
 </ul></DL>
</DD>
</DL>
<HR>

<A NAME="groupWriteIsolated(java.lang.String, int)"><!-- --></A><H3>
groupWriteIsolated</H3>
<PRE>
public void <B>groupWriteIsolated</B>(java.lang.String&nbsp;dbname,
                               int&nbsp;options)</PRE>
<DL>
<DD>Writes a group of objects to a database and isolate the objects on 
 their own page. A group write isolated operation works like a 
 normal group write, but it suggests that the database isolate the 
 given objects on their own page.  This means that:
 <p>
 VERSANT always uses a new page to store each object.<p>
 
 Each such new page will not be used for storing objects except 
 through a "group write clustered" operation in which the parent 
 object is the object on the page.<p>
 
 If using the <code>Constants.CLEAN_CODS</code> option, the cached 
 object descriptor table of all entries except those for class 
 objects, dirty objects, and pinned objects are immediately cleared. 
 When a cached object descriptor is released from the cached 
 object descriptor table, the corresponding object is released from 
 memory.  Releasing cached object descriptors invalidates handles to
 the corresponding objects.<p>
 
 You should not use this option if a dirty object contains a handle 
 to an unpinned object (i.e., an object whose cached object 
 descriptor has been zapped), because at commit time VERSANT is not
 able to find the cached object descriptor for the target object. 
 Similarly, after clearing cached object descriptors, you should not
 dirty an object containing a handle to an object whose cached 
 object descriptor has been cleared, as this could result in a 
 corrupted handle.<p>
 
 If you do clear the cached object descriptor for an object that is
 the target of a handle in a dirty object, you get the VERSANT error
 <code>OM_COD_ALREADY_FREED</code> at commit time because VERSANT 
 is not able to find the cached object descriptor for the target 
 object. However, if you continue in the same transaction after 
 clearing cached object descriptors, VERSANT may reuse a previously 
 zapped cached object descriptor, in which case you will corrupt the
 handle without getting an error. Releasing cached object 
 descriptors frees space in the cached object descriptor table for 
 reuse, which is useful if you need to reclaim space in the 
 application process heap during a session that references a very 
 large number (say, a million or more) of objects.<p>
 
 Clearing the cached object descriptor table does not affect the 
 database state of an object.<p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dbname</CODE> - Name of the database to write the objects to.<DD><CODE>options</CODE> - The valid options are:
 <ul>
 <li>0 : 
        No options specified</li>
 <li><code>Constants.FREE_OBJECTS</code> : 
        Release objects in the array from the VERSANT front-end object cache </li>
 <li><code>Constants.CLEAN_CODS</code> : 
        Release the cached object descriptors of objects in the array 
        from the VERSANT front-end object cache.</li>
 </ul></DL>
</DD>
</DL>
<HR>

<A NAME="groupDeleteObjects(java.lang.String)"><!-- --></A><H3>
groupDeleteObjects</H3>
<PRE>
public void <B>groupDeleteObjects</B>(java.lang.String&nbsp;dbname)</PRE>
<DL>
<DD>Deletes the objects in this <code>vector</code> from the database 
 <code>db</code> and returns the objects not deleted to an instance 
 variable of <code>VException</code>.
 <p>
 This method enhances performance by deleting a group of objects 
 with the least possible number of network messages. By comparison,
 <code>deleteObject()</code>sends a separate network message for 
 each object to be deleted.<p>
 
 This method releases the deleted objects from the object cache.<p>
 This method deletes all the specified objects that it can. If this
 method encounters objects that fail the time stamp validation or 
 objects that are not in the specified database, this method returns
 the handles of the failed objects to an instance variable of 
 <code>VException</code>. For other deletion failures, this method 
 returns the appropriate error number to the error number variable.<p>
 
 To access the objects not deleted, use <code>getFailedHandles()</code> 
 on <code>VException</code>. The failed objects <code>vector</code> 
 can contain:
 <p>
 <li>New objects
 <li>Updated objects marked as dirty
 <li>Non-cached objects
 <li>Objects deleted by other applications
 </ul>
 <p>
 
 An error occurs if this <code>vector</code> contains a class object.<p>
 In an optimistic locking session, before deleting an object from 
 its database, this method compares the time stamp for each object 
 in the <code>objs</code> parameter with the time stamp for the 
 corresponding database object. If the time stamp for your copy 
 object is not equal to the time stamp for the database counterpart,
 then it fails the time stamp validation, which means that the 
 database object has been updated since the time you read in your 
 copy. Handles to objects that fail the time stamp validation are
 returned. This kind of failure to delete can occur only in an 
 optimistic locking session.<p>
 
 If you are trying to delete an object that has already been deleted
 by another user, its object handle are returned along with other 
 objects that were not found in the specified database.<p>
 If an object does not have a time stamp attribute, no time stamp 
 validation is performed. In this case, in an optimistic locking 
 session, blind overwrites of updates made by others can occur.<p>
 The contents of the <code>vector</code> of object handles in
 <code>VException</code> will depend on what happened.<p>
 
 The failed objects <code>vector</code> returned by 
 <code>getFailedHandles()</code> 
 can contain the following:<p>
 Object not found.<p>
 <code>(0.0.0), not_found, .., (0.0.0)</code><p>
        <ul>If you specify objects not in the specified database, you get 
        a null object handle, a list of object handles for the objects not 
        found, and then another null object handle. Also, the return value
        of <code>getErrNo()</code> resolves to one of following: 
        <code>SM_E_KEY_NOT_FOUND</code>, <code>SCH_OBJ_NOT_FOUND</code>, 
        or <code>OB_NO_SUCH_OBJECT</code>.</ul><p>
 In an optimistic locking session, new objects are simply dropped 
 from the cache. Depending on what happened, the failed objects 
 <code>vector</code> can contain the above or any of the following:<p>
 Outdated time stamp error.<p>
 <code>failed_time_stamp,</code> <code>..,</code> <code>(0.0.0),
 </code> <code>(0.0.0)</code><p>
 
        <ul>If some objects fail the time stamp validation, you get a list
        of object handles for the objects that failed, followed by two null
        object handles.</ul><p>
 Outdated time stamp error plus object not found error.<p>
 <code>failed_time_stamp, .., (0.0.0), not_found, .., (0.0.0)</code><p>
        <ul>If some objects fail the time stamp validation and some 
        objects are not in the specified database, you get a list of object
        handles for the objects that failed the time stamp validation, 
        followed by one null object handle, followed by a list of object
        handles for the objects that were not found, followed by one null
        object handle.</ul><p>
 You could have specified an incorrect database or<p>
 The object may have already been deleted by another user.<p>
 If object handles are returned to the failed object vector, what 
 you do next is up to you. Typically you would refresh your copy of
 the database object with <code>refreshObject()</code>, examine the 
 refreshed object, and then decide again whether to delete it.<p>
 Deletions are not persistent until committed.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dbname</CODE> - The name of the database from which to 
                                delete objects.</DL>
</DD>
</DL>
<HR>

<A NAME="migrateObjects(java.lang.String, java.lang.String)"><!-- --></A><H3>
migrateObjects</H3>
<PRE>
public void <B>migrateObjects</B>(java.lang.String&nbsp;sourcedb,
                           java.lang.String&nbsp;targetdb)</PRE>
<DL>
<DD>Physically moves the objects in this <code>vector</code> from 
 database <code>sourcedb</code> to database <code>targetdb</code>.
 <p>
 Logging must be on in both databases for 
 atomic operation to be guaranteed.
 <p>
 Migrating an object does not change its object identifier, so 
 handles to the object are still valid after the migration.<p>
 If a copy of the class and superclass objects for the migrated 
 objects do not already exist in the target database, they are 
 created.<p>
 If classes have the same name but differing definitions in the
 source and target databases, the migration returns an error, and 
 you must stop and synchronize the definitions in order to make the
 migration.<p>
 You cannot migrate a system class, a schema, or checked out object.
 The returned<code> vector </code>contains these objects plus 
 objects not in the source database and objects whose schema is 
 incompatible with existing definitions in the target database.<p>
 An exception is raised if the objects are not in the source 
 database or if you are not connected to both databases at the time
 of the move. If you get an exception, you can get the error number
 with <code>getErrno()</code> and obtain the objects not migrated
 with <code>getFailedHandles()</code>.<p>
 The <code>migrateObjects()</code> method is useful when you want to
 move an object from either a personal or a group database to a 
 group database.<p>
 It is also useful when you want to increase or decrease the amount 
 of space in a database or make schema changes by creating a new 
 database, migrating existing objects to it, and then dropping the 
 old database.<p>
 When you migrate objects created in a personal database to a group
 database, make sure that the migrated objects do not reference 
 objects left in a personal database.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sourcedb</CODE> - The source database. If you specify 
                <code>""</code> for the source database, the objects are located 
                from the set of currently connected databases.<DD><CODE>targetdb</CODE> - Target database. If you specify 
                <code>""</code> for the target database, the objects are migrated 
                to the session database.</DL>
</DD>
</DL>
<HR>

<A NAME="copyObjects(java.lang.String, java.lang.String)"><!-- --></A><H3>
copyObjects</H3>
<PRE>
public void <B>copyObjects</B>(java.lang.String&nbsp;sourcedb,
                        java.lang.String&nbsp;targetdb)</PRE>
<DL>
<DD>Without changing object identifiers, copies the objects in this 
 <code>vector</code> from one database to another.
 <p>
 If you specify <code>""</code>, the database associated with the 
 first object in the <code>vector</code> is used.<p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sourcedb</CODE> - The source database.<DD><CODE>targetdb</CODE> - Target database.
 
        <ul>If you specify <code>""</code>, the session database is used.
        Copying objects is useful if you want to replicate selected objects
        in another database. For example, instead of using the VERSANT 
        Fault Tolerant Server option that provides synchronous database 
        replication, you could create your own asynchronous database 
        replication mechanism using event notification and this method.<p>
        An object cannot be copied if it is not in the source database; if
        it is a system, schema, or checked out object; or if it is an 
        object whose schema is incompatible with the definition in the 
        target database.<p>
        If some objects cannot be copied, an exception is raised. You can 
        then use <code>getErrno()</code> to get the error number and 
        <code>getFailedHandles()</code> to get handles to the database 
        source objects that were not copied.<p>
        Referenced objects not in this <code>vector</code> are not copied.
        If both objects and referenced objects are copied, handles in the 
        copied objects point to the copied linked objects. If objects are 
        copied but their referenced objects are not copied, handles in the 
        copied objects point back to the original objects.<p>
        The LOID of the objects are preserved after the copy.<p>
        You must be connected to both databases at the time of the copy.<p>
        Logging must be on in all connected databases for atomic operation 
        to be guaranteed.<p>
        If a schema object for an instance object being copied does not 
        exist in the target database, then it is copied to the target 
        database. If a class with the same name and a different definition
        already exists in the target database, an error occurs.<p>
 </ul><DT><B>See Also:</B><DD><A HREF="../../../com/versant/fund/HandleVector.html#migrateObjects(java.lang.String, java.lang.String)"><CODE>HandleVector.migrateObjects(java.lang.String, java.lang.String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="releaseObjects(int)"><!-- --></A><H3>
releaseObjects</H3>
<PRE>
public void <B>releaseObjects</B>(int&nbsp;option)</PRE>
<DL>
<DD>Immediately releases the memory space used by the objects in this
 vector.
 <p>
 Alternatives for the pinning
 <code>options</code>
 parameters are:
 <ul> 
 <li><code>0</code> : Release all objects.
 <li><code>Constants.SKIP_NEW</code> :
 Do not release new objects.
 <li><code>Constants.SKIP_DIRTY</code> : 
 Do not release dirty objects.
 </ul>
 This method can be used when you have no further use for a set of
 objects in the current transaction.<p>
 All changes made to the released objects since the last time they
 were written to the server are dropped. An object may have been 
 written by VERSANT during a transaction due to object swapping, a 
 group write, or a query. Since VERSANT writes objects per its needs
 for memory rather than per programming logic, this means that the 
 final state of an object may be uncertain if you have changed it 
 before calling this function. If you have changed an object and 
 you want the changes to be written to the database at the next 
 commit, you should write the object before releasing it.<p>
 This method is useful when you have a snapshot lock (a null lock) 
 on a set of objects, which means that once the objects are cached 
 in memory, they are not updated even if they are updated in the 
 database. To get the current state of the objects, release them 
 from memory and get them again. The object is reread the next time 
 it is accessed. This behavior is similar to using the 
 <code>refreshObject()</code> method.<p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>option</CODE> - Pinning options.<DT><B>See Also:</B><DD><A HREF="../../../com/versant/fund/Handle.html#releaseObject()"><CODE>Handle.releaseObject()</CODE></A>, 
<A HREF="../../../com/versant/fund/HandleVector.html#groupWriteObjects(int)"><CODE>HandleVector.groupWriteObjects(int)</CODE></A>, 
<A HREF="../../../com/versant/fund/Handle.html#refreshObject(int)"><CODE>Handle.refreshObject(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="zapObjects()"><!-- --></A><H3>
zapObjects</H3>
<PRE>
public void <B>zapObjects</B>()</PRE>
<DL>
<DD>Releases the objects in this <code>vector</code> from memory and 
 makes their cached object descriptors available for re-use.
 <p>
 Releasing cached object descriptors invalidates handles to the 
 corresponding objects.<p>
 Handles in this vector should not be re-used after invocation of 
 this method.<p>
 
 Because this method invalidates object handles, it should be used
 with care. If this function is used incorrectly, it could corrupt
 handles.
 <p>
 <ul>
        <li>You should never release the cached 
        object descriptor for a class object.
        <li>You should never release the cached object descriptor for an 
        object marked as dirty.
        <li>You should never release the cached object descriptor for an 
        object, which is the target of a handle in an object, marked as 
        dirty.
 </ul>
 <p>
 After using this method, you should never dirty an object that has
 a handle to an object whose cached object descriptor has been 
 zapped.
 <p>
 Usually, if you zap the cached object descriptor for an object 
 that is the target of a handle and then you commit the dirty 
 object containing the handle, you get the error, 
 <code>OM_COD_ALREADY_FREED</code>, because VERSANT is not able to 
 find the cached object descriptor for the target object. However, 
 if you continue in the same transaction after using this function, 
 VERSANT may reuse the previously zapped cached object descriptor, 
 in which case you will corrupt the handle without getting an error.<p>
 Releasing cached object descriptors frees space in the cached 
 object descriptor table for reuse, which is useful if you need to 
 reclaim space in the application process heap during a session that
 references a very large number (say, a million or more) of 
 objects.<p>
 When you run out of space in the application process heap, you see 
 error number <code>4161, OM_HEAP_NOMEM,</code> <code>"Out of 
 front-end heap memory"</code>. The initial size of the application 
 process heap is determined by the <code>heap_size</code>
 parameter in the application process parameter file, but it expands
 dynamically as needed. Thus, this error message can also mean that
 the objects themselves are taking too much space, so first try 
 unpinning the objects and only use <code>zapcods()</code> 
 as a last resort.<p>
 Clearing the cached object descriptor table does not affect the 
 database state of an object.<p>
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/versant/fund/HandleVector.html#releaseObjects(int)"><CODE>HandleVector.releaseObjects(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setObjectsDatabase(java.lang.String)"><!-- --></A><H3>
setObjectsDatabase</H3>
<PRE>
public void <B>setObjectsDatabase</B>(java.lang.String&nbsp;dbName)</PRE>
<DL>
<DD>Specifies the database from which persistent objects in this vector
 are to be fetched.
 <p>
 This method is useful when you use asynchronous database 
 replication and have a vector of objects that have the same loids 
 in each of two databases. If this method is not invoked, the 
 VERSANT server will choose the database from which to fetch the 
 replicated objects.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dbName</CODE> - The specified database from which to 
                                fetch the objects.</DL>
</DD>
</DL>
<HR>

<A NAME="getClosure(java.lang.String, int, boolean, int)"><!-- --></A><H3>
getClosure</H3>
<PRE>
public <A HREF="../../../com/versant/fund/HandleVector.html" title="class in com.versant.fund">HandleVector</A> <B>getClosure</B>(java.lang.String&nbsp;dbName,
                               int&nbsp;levels,
                               boolean&nbsp;toPin,
                               int&nbsp;lockmode)</PRE>
<DL>
<DD>Get closure of objects.
 <p>
 For the number of levels:
 <ul>
 <li>Specify <code>0</code> to return only the found objects.
 <li>Specify <code>-1</code> to return all objects linked directly 
 or indirectly to the found objects.
 <li>Specify a positive number to indicate the number of levels of 
 links to follow beginning with the found objects. For example, 
 specify <code>1</code> to return objects that are the direct 
 target of links in the objects found by the predicate, and specify
 <code>2</code> also to return objects that are the target of links 
 in the first level of linked objects.
 </ul>
 <p>
 If objects are pinned, you need to later manually unpin the objects using 
 <code>com.versant.fund.Handle.unpinObject()</code> or release them 
 by ending the transaction.<p>
 If you 
 specify lockmode to be <code>RLOCK</code> or <code>IRLOCK</code>, 
 and have used 
 <code>FundSession.setThreadOptions(Constants.DROP_RLOCK)</code>,
 then the database server will drop the <code>RLOCK</code> or 
 <code>IRLOCK</code> after the closure evaluation. The available 
 options for <code>lockmode</code> are:
 <ul>
 <li><code>Constants.WLOCK</code>       : Write lock </li>
 <li><code>Constants.RIWLOCK</code> : Read/intention-write lock </li>
 <li><code>Constants.IWLOCK</code>      : Intention-write lock </li>
 <li><code>Constants.ULOCK</code>       : Update lock </li>
 <li><code>Constants.RLOCK</code>       : Read lock </li>
 <li><code>Constants.IRLOCK</code>      : Intention-read lock </li>
 <li><code>Constants.NOLOCK</code>      : No lock </li>
 </ul>
 Using persistent objects in the array as starting-point objects, 
 evaluate, in the named database, objects reachable from the 
 starting point objects for the specified number of levels, and 
 return an object array to contain both the starting-point objects
 and their referenced objects. The returned objects are placed in 
 VERSANT object cache, optionally pinned, and have either a default
 lock or a specified lock.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dbName</CODE> - The name of the database to do a 
                                closure in.<DD><CODE>levels</CODE> - The number of levels of links to 
                                traverse starting from the objects found by the predicate.<DD><CODE>toPin</CODE> - Sets whether or not returned objects are
                                to be pinned in the VERSANT object cache.<DD><CODE>lockmode</CODE> - The lockmode to be used.</DL>
</DD>
</DL>
<HR>

<A NAME="refreshObjects(java.lang.String, int)"><!-- --></A><H3>
refreshObjects</H3>
<PRE>
public void <B>refreshObjects</B>(java.lang.String&nbsp;dbname,
                           int&nbsp;lockmode)</PRE>
<DL>
<DD>Refresh object.
 <p>
 Options for 
 <code>lockmode</code> are:
 <ul>
 <li><code>Constants.WLOCK</code>       : Write lock </li>
 <li><code>Constants.RIWLOCK</code> : Read/intention-write lock </li>
 <li><code>Constants.IWLOCK</code>      : Intention-write lock </li>
 <li><code>Constants.ULOCK</code>       : Update lock </li>
 <li><code>Constants.RLOCK</code>       : Read lock </li>
 <li><code>Constants.IRLOCK</code>      : Intention-read lock </li>
 <li><code>Constants.NOLOCK</code>      : No lock </li>
 </ul>
 This method updates the objects in this <code>vector</code> in the 
 object memory cache with the current state of the objects in the 
 source database specified as <code>dbname</code>, and sets the 
 lock described in the lock mode <code>lockmode</code> on the 
 specified objects.<p>
 For a complete description of lock modes, see the <i>VERSANT 
 Database Fundamentals</i>.<p>
 If an object in this <code>vector</code> is not currently in memory,
 it is found and pinned in memory. All objects must come from the 
 same database.<p>
 If an object in this <code>vector</code> cannot be refreshed, an 
 exception is raised. You can check the error number with 
 <code>getErrno()</code> and obtain handles to the objects not 
 refreshed with <code>getFailedHandles()</code>.<p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dbname</CODE> - The source database.<DD><CODE>lockmode</CODE> - The mode of the lock.<DT><B>See Also:</B><DD><A HREF="../../../com/versant/fund/Handle.html#refreshObject(int)"><CODE>Handle.refreshObject(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="checkTimestamps()"><!-- --></A><H3>
checkTimestamps</H3>
<PRE>
public void <B>checkTimestamps</B>()</PRE>
<DL>
<DD>Determines whether database source objects have changed since the 
 copies in this handle <code>vector</code> have been read into the 
 object cache.
 <p>
 This method checks the time stamps for dirty objects in receiver. 
 By comparison, <code>checkAllTimestamps()</code> checks all objects
 marked as dirty.<p>
 Obsolete object copies in the object cache can occur when you are 
 working with unlocked objects, which usually occurs in the context
 of an optimistic locking session. For objects containing a time 
 stamp attribute, this method compares time stamps to detect 
 obsolete objects. At commit time, VERSANT first increments the 
 time stamp (if it exists) for each dirty object within its scope 
 and then compares the time stamp for the dirty object with the time
 stamp of its database source object.<p>
 Objects can fail time stamp validation in the following situations:
 <p>
 <ul>
        <li> If the time stamp for a dirty object is not greater than the time 
        stamp for the database object. This can occur if another user has
        updated the database object
        after you have released the lock on your copy in your optimistic 
        transaction set.
        <li> If a dirty object is not found in its database, because it has been
        previously deleted by another user.
        <li> If a dirty object is not found in its database, because it has been
        previously migrated to another database by another user.
 </ul>
 <p>
 
 After running this method, if a <code>VException</code> is thrown,
 you can check for a timestamp error with <code>getErrno()</code>. 
 The timestamp error number is 4036 and resolves to 
 <code>OM_TR_INVALID_TS</code>. You can get the failed objects with
 <code>getFailedHandles()</code> on <code>VException</code>.<p>
 The format of the contents of the <code>vector</code> returned by 
 <code>getFailedHandles()</code> can be any of the following:<p>
 Outdated time stamp error.<p>
 <ul><code>failed_time_stamp, .., (0.0.0), (0.0.0)</code><p>
 If some objects fail a time stamp validation, you get a list 
 of object handles for the objects that failed, followed by two 
 empty object handles.</ul>
 Outdate time stamp error plus object not found error.<p>
 <ul><code>failed_time_stamp, .., (0.0.0), not_found, .., (0.0.0)</code><p>
 If some objects fail a time stamp validation and some objects 
 are not in the session database, you get a list of object handles 
 for the objects that failed the time stamp validation, followed by 
 one empty object handle, followed by the object handles of objects 
 that were not found, followed by one empty object handle.</ul><p>
 
 When you consider what objects to check, you should place all 
 objects marked dirty in <code>objs</code> and all objects 
 inter-related to them. Since this method checks only dirty objects,
 marks the inter-related objects as dirty, so that their timestamps 
 are checked.<p>
 When you consider inter-related objects, you should consider both 
 hierarchical relationships (such as subclass objects) and logical 
 relationships in which, for example, an update to one object 
 depends upon the value in another object (although the other object
 is not marked dirty). An example of a logical relationship is when,
 say, you want to change <code>B</code> only if <code>A</code> is 
 greater than <code>10</code>. In this case, you could place both 
 <code>A</code> and <code>B</code> into the input array.<p>
 If some objects fail the timestamp comparison and are returned, 
 what you do next is up to you. You could refresh the failed objects,
 examine the refreshed objects, and then decide whether to apply 
 your update again. The safest thing to do (and the recommended
 approach) is to rollback the transaction and begin again.<p>
 This method acquires the default lock, which is typically a read 
 lock, on each dirty object examined. You might want to change the
 default lock if you do not want to hold locks on any objects until 
 you commit. To find or change the current default lock, you can 
 call <code>defaultLockMode()</code>.<p>
 
 If you do reset the default lock to <code>NOLOCK</code> before 
 running this method, there is a chance that some of your copy 
 objects have become obsolete, because other users will have time 
 to change objects between the time you run this function and the 
 time you perform a commit. Thus, we recommend that you call this 
 function, using default read locks, just before a commit so as to 
 both get the safety of read locks and to reduce the duration of the
 locks being held.<p>
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/versant/fund/MSession.html#checkAllTimestamps()"><CODE>MSession.checkAllTimestamps()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="downgradeLocksTo(int)"><!-- --></A><H3>
downgradeLocksTo</H3>
<PRE>
public void <B>downgradeLocksTo</B>(int&nbsp;lockmode)</PRE>
<DL>
<DD>Downgrades or releases locks on the objects in this 
 <code>vector</code> without flushing the objects from the 
 application cache.
 <p>
 The available options for <code>lockmode</code> are:
 <ul>
 <li><code>Constants.WLOCK</code>       : Write lock </li>
 <li><code>Constants.RIWLOCK</code> : Read/intention-write lock </li>
 <li><code>Constants.IWLOCK</code>      : Intention-write lock </li>
 <li><code>Constants.ULOCK</code>       : Update lock </li>
 <li><code>Constants.RLOCK</code>       : Read lock </li>
 <li><code>Constants.IRLOCK</code>      : Intention-read lock </li>
 <li><code>Constants.NOLOCK</code>      : No lock </li>
 </ul>

 For a complete description of lock modes, see the <i>VERSANT 
 Database Fundamentals</i>.<p>
 You could use <code>downgradeLockTo()</code> on <code>Handle</code>
 to release locks just on a specific object, but this method is 
 faster if multiple objects are involved.<p>
 To release a lock, set the lock mode to <code>NOLOCK</code>.<p>
 If the specified lockmode is stronger than or not comparable to 
 the currently held lock mode, no downgrading occurs.<p>
 The lock on the class object for an instance is not downgraded.<p>
 If locks are downgraded on modified objects, the ability of the 
 transaction to rollback may be jeopardized.<p>
 If not successful, one of the following errors is raised: 
 <code>OB_NULL</code>, <code>OB_BADLOCK</code> or 
 <code>OB_NO_SUCH_OBJECT</code>.<p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>lockmode</CODE> - The mode of the lock.<DT><B>See Also:</B><DD><A HREF="../../../com/versant/fund/Handle.html#downgradeLockTo(int)"><CODE>Handle.downgradeLockTo(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="commitAndRetain()"><!-- --></A><H3>
commitAndRetain</H3>
<PRE>
public void <B>commitAndRetain</B>()</PRE>
<DL>
<DD>Commits all new and dirty objects in this handle vector.
 <p>
 The commit writes new objects in this <code>vector</code> to the 
 default database, writes changes to dirty objects in this 
 <code>vector</code> to their source databases, releases all short 
 locks on all objects, retains all objects in the object cache, 
 maintains all persistent locks on all objects, and starts a new 
 short transaction. Afterwards, you can use object handles.<p>
 This method is useful when you are reading many objects and 
 updating only a few, because VERSANT does not have to scan all 
 objects in the object cache looking for those that are new or 
 marked dirty.<p>
 
 Take care to place all new and dirty objects in this vector. 
 Afterwards, the dirty status of new and dirty objects not in this 
 <code>vector</code> remains unchanged, which could lead to 
 unintended results if you next perform a normal commit or end your
 session with a commit.<p>
 
 This method fails and raises an exception if it times out before 
 obtaining write locks on all dirty objects or if you are not 
 connected to all source databases for the new and dirty objects. If
 you are using time stamps, this method continues if it encounters
 objects that fail the timestamp validation, so that it can identify
 all such objects, but the commit itself fails.<p>
 After running this method, if a <code>VException</code> is thrown,
 you can get an error number by using <code>getErrorNo()</code> on 
 <code>VException</code> and get failed objects, if any, with 
 <code>getFailedHandles()</code> on <code>VException</code>. 
 If this method succeeds, the return value of <code>getErrno()</code>
 is zero.<p>
 In non-optimistic locking sessions, the format of the contents of 
 the <code>vector</code>
 returned by <code>getFailedHandles()</code> can be the following:<p>
 Object not found.<p>
 <code>(0.0.0), not_found_obj, .., (0.0.0)</code><p>
 <ul>If an object is not found, you get an empty object handle, a 
 list of object handles for the objects not found, and then another 
 empty object handle. The return value of <code>getErrno()</code>
 resolves to one of following: <code>SM_E_KEY_NOT_FOUND</code>,
 <code>SCH_OBJ_NOT_FOUND</code>, or <code>OB_NO_SUCH_OBJECT</code>.</ul><p>
 
 Obsolete object copies in the object cache can occur when you are 
 working with unlocked objects, which usually occurs in the context
 of an optimistic locking session. For objects containing a time
 stamp attribute, this method compares time stamps to detect
 obsolete objects. At commit time, VERSANT first increments the 
 time stamp (if it exists) for each dirty object within its scope 
 and then compares the time stamp for the dirty object with the time
 stamp of its database source object.<p>
 At commit time, obsolete copies lead to time stamp validation 
 failures in the following situations:
 <p>
 <ul>
 <li> If the time stamp for a dirty object is not greater than the time 
 stamp for the database object.
 <li> If a dirty object is not found in its database, because it has been
 previously deleted by another user.
 <li> If a dirty object is not found in its database, because it has been
 previously migrated to another database by another user.
 </ul>
 <p>
 If there are obsolete copies, the format of the contents of the 
 return <code>vector</code>
 can be any of the following:<p>
 Outdated time stamp error.<p>
 <ul><code>failed_time_stamp_obj, .., (0.0.0), (0.0.0)</code><p>
 If some objects fail a time stamp validation, you get a list 
 of object handles for the objects that failed, followed by two 
 empty object handles.</ul><p>
 Outdate time stamp error plus object not found error.<p>
 <ul><code>failed_time_stamp_obj, .., (0.0.0), not_found_obj, .., (0.0.0)</code><p>
 If some objects fail a time stamp validation and some objects
 are not found, you get a list of object handles for the objects 
 that failed the time stamp validation, followed by one empty object
 handle, followed by the object handles of objects that were not 
 found, followed by one empty object handle.</ul><p>
 If time stamp validation failures occur, what you do next is up to
 you. The recommended course of action is to rollback the entire 
 transaction and begin again. Alternately, you can refresh your copy
 of the database object with <code>refreshObject()</code>, examine 
 the refreshed object, and then decide whether to apply your update
 again.<p>
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/versant/fund/MSession.html#checkpointCommit()"><CODE>MSession.checkpointCommit()</CODE></A>, 
<A HREF="../../../com/versant/fund/MSession.html#commit()"><CODE>MSession.commit()</CODE></A>, 
<A HREF="../../../com/versant/fund/HandleVector.html#checkpointCommit()"><CODE>HandleVector.checkpointCommit()</CODE></A>, 
<A HREF="../../../com/versant/fund/MSession.html#rollback()"><CODE>MSession.rollback()</CODE></A>, 
<A HREF="../../../com/versant/fund/MSession.html#rollbackAndRetain()"><CODE>MSession.rollbackAndRetain()</CODE></A>, 
<A HREF="../../../com/versant/fund/HandleVector.html#rollbackAndRetain()"><CODE>HandleVector.rollbackAndRetain()</CODE></A>, 
<A HREF="../../../com/versant/fund/MSession.html#checkAllTimestamps()"><CODE>MSession.checkAllTimestamps()</CODE></A>, 
<A HREF="../../../com/versant/fund/HandleVector.html#checkTimestamps()"><CODE>For information on timestamps and optimistic locking sessions, see
 the <i>VERSANT 
 Database Fundamentals</i>.<p></CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="checkpointCommit()"><!-- --></A><H3>
checkpointCommit</H3>
<PRE>
public void <B>checkpointCommit</B>()</PRE>
<DL>
<DD>Performs a checkpoint commit all new and dirty objects in this 
 handle vector.
 <p>
 The checkpoint commit:
 <p>
 <ul>
 <li>Writes new objects in this <code>vector</code> to the default 
 database
 <li>Writes changes to dirty objects in this <code>vector</code> to 
 their source databases
 <li>Maintains short and persistent locks on all objects
 <li>Maintains the object cache
 <li>Starts a new short transaction.
 <li>Afterwards, you can continue to use object handles.
 </ul>
 <p>
 This method is useful when you are reading many objects and 
 updating only a few, because VERSANT does not have to scan all 
 objects in the object cache looking for those that are new or 
 marked dirty.<p>
 Place all new and dirty objects in this vector. The dirty status of
 new and dirty objects that are not in this <code>vector</code> 
 remains unchanged.
 This could lead to unintended results if you then perform a normal 
 commit or end your session with a commit.<p>
 This method fails and raises an exception if it times out before 
 obtaining write locks on all dirty objects or if you are not 
 connected to all source databases for the new and dirty objects. If
 you are using time stamps, this method continues if it encounters 
 objects that fail time stamp validation, so that it can identify 
 all such objects, but the commit itself will fail.<p>
 After running this method, if a <code>VException</code> is thrown, 
 you can get an error number by using <code>getErrorNo()</code> on 
 <code>VException</code> and get failed objects, if any, with 
 <code>getFailedHandles()</code> on <code>VException</code>. If this
 method succeeds, the return value of <code>getErrno()</code> is 
 zero.<p>
 In non-optimistic locking sessions, the format of the contents of 
 the <code>vector</code> returned by <code>getFailedHandles()
 </code> can be the following:<p>
 Object not found<p>
 <code>(0.0.0), not_found_obj, .., (0.0.0)</code><p>
 <ul>If an object is not found, you get an empty object handle, a 
 list of object handles for the objects not found, and then another 
 empty object handle. The return value of <code>getErrno()
 </code>resolves to one of following: <code>SM_E_KEY_NOT_FOUND</code>, 
 <code>SCH_OBJ_NOT_FOUND</code>, or <code>OB_NO_SUCH_OBJECT</code>.</ul><p>
 Obsolete object copies in the object cache can occur when you are 
 working with unlocked objects, which usually occurs in the context 
 of an optimistic locking session. For objects containing a time 
 stamp attribute, this method compares time stamps to detect 
 obsolete objects. At commit time, VERSANT first increments the time
 stamp (if it exists) for each dirty object within its scope and 
 then compares the time stamp for the dirty object with the time 
 stamp of its database source object.<p>
 At commit time, obsolete copies lead to time stamp validation 
 failures in the following situations:<p>
 If the time stamp for a dirty object is not greater than the time 
 stamp for the database object.<p>
 If a dirty object is not found in its database, because it has been
 previously deleted by another user.<p>
 If a dirty object is not found in its database, because it has been
 previously migrated to another database by another user.<p>
 If there are obsolete copies, the format of the contents of the 
 return <code>vector</code> can be any of the following:<p>
 Outdated time stamp error.<p>
 <ul><code>failed_time_stamp_obj, .., (0.0.0), (0.0.0)</code><p>
 If some objects fail a time stamp validation, you get a list 
 of object handles for the objects that failed, followed by two 
 empty object handles.</ul><p>
 Outdate time stamp error plus object not found error.<p>
 <ul><code>failed_time_stamp_obj, .., (0.0.0), not_found_obj, .., (0.0.0)</code><p>
 If some objects fail a time stamp validation and some objects 
 are not found, you get a list of object handles for the objects 
 that failed the time stamp validation, followed by one empty object
 handle, followed by the object handles of objects that were not 
 found, followed by one empty object handle.</ul><p>
 If time stamp validation failures occur, what you do next is up to
 you. The recommended course of action is to rollback the entire 
 transaction and begin again. Alternately, you can refresh your copy
 of the database object with <code>refreshObject()</code>, examine 
 the refreshed object, and then decide whether to apply your update 
 again.<p>
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/versant/fund/MSession.html#checkpointCommit()"><CODE>MSession.checkpointCommit()</CODE></A>, 
<A HREF="../../../com/versant/fund/MSession.html#commit()"><CODE>MSession.commit()</CODE></A>, 
<A HREF="../../../com/versant/fund/HandleVector.html#commitAndRetain()"><CODE>HandleVector.commitAndRetain()</CODE></A>, 
<A HREF="../../../com/versant/fund/MSession.html#rollback()"><CODE>MSession.rollback()</CODE></A>, 
<A HREF="../../../com/versant/fund/MSession.html#rollbackAndRetain()"><CODE>MSession.rollbackAndRetain()</CODE></A>, 
<A HREF="../../../com/versant/fund/HandleVector.html#rollbackAndRetain()"><CODE>HandleVector.rollbackAndRetain()</CODE></A>, 
<A HREF="../../../com/versant/fund/MSession.html#checkAllTimestamps()"><CODE>MSession.checkAllTimestamps()</CODE></A>, 
<A HREF="../../../com/versant/fund/HandleVector.html#checkTimestamps()"><CODE>For information on timestamps and optimistic locking sessions, see
 the <i>VERSANT Database Fundamentals</i>.<p></CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="rollbackAndRetain()"><!-- --></A><H3>
rollbackAndRetain</H3>
<PRE>
public void <B>rollbackAndRetain</B>()</PRE>
<DL>
<DD>Rollbacks all new and dirty objects in this handle vector.
 <p>
 The rollback releases the new and dirty objects in this 
 <code>vector</code> from the object cache, releases locks held on
 the new and dirty objects in this vector, retains remaining objects
 in the object cache, and drops all changes made in databases on all
 objects.<p>
 This method is useful when you are reading many objects and 
 updating only a few, because VERSANT does not have to scan all 
 objects in the object cache looking for those that are new or 
 marked dirty.<p>
 This method does not check timestamps.<p>
 Afterwards you can use handles to all objects.<p>
 This method will timeout if it cannot acquire write locks on 
 objects within its scope. It returns an exception if you are not 
 connected to the source databases for all objects in the handle 
 vector. If it fails, you can check the error number by using 
 <code>getErrno()</code> on <code>VException</code>.<p>
 Note that this option releases and drops locks on the new and 
 dirty objects in this vector. If you want to rollback changes to 
 selected objects while holding their locks on those objects, you 
 can refresh them with <code>refreshObject()</code> or
 <code>refreshObjects()</code>, or release and get them with 
 <code>releaseObject()</code>
 and <code>locateObject()</code>.<p>
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/versant/fund/MSession.html#checkpointCommit()"><CODE>MSession.checkpointCommit()</CODE></A>, 
<A HREF="../../../com/versant/fund/HandleVector.html#checkpointCommit()"><CODE>HandleVector.checkpointCommit()</CODE></A>, 
<A HREF="../../../com/versant/fund/MSession.html#commit()"><CODE>MSession.commit()</CODE></A>, 
<A HREF="../../../com/versant/fund/HandleVector.html#commitAndRetain()"><CODE>HandleVector.commitAndRetain()</CODE></A>, 
<A HREF="../../../com/versant/fund/MSession.html#rollback()"><CODE>MSession.rollback()</CODE></A>, 
<A HREF="../../../com/versant/fund/MSession.html#rollbackAndRetain()"><CODE>MSession.rollbackAndRetain()</CODE></A>, 
<A HREF="../../../com/versant/fund/MSession.html#checkAllTimestamps()"><CODE>MSession.checkAllTimestamps()</CODE></A>, 
<A HREF="../../../com/versant/fund/HandleVector.html#checkTimestamps()"><CODE>HandleVector.checkTimestamps()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="concatWith(com.versant.fund.HandleVector)"><!-- --></A><H3>
concatWith</H3>
<PRE>
public <A HREF="../../../com/versant/fund/HandleVector.html" title="class in com.versant.fund">HandleVector</A> <B>concatWith</B>(<A HREF="../../../com/versant/fund/HandleVector.html" title="class in com.versant.fund">HandleVector</A>&nbsp;v)</PRE>
<DL>
<DD>Returns a new instance of <code>HandleVector</code> that is the 
 concatenation of the contents of this instance and the 
 <code>vector</code> specified as <code>v</code>.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - The <code>vector</code> to concatenate with 
                        <code>this</code> <code>vector</code>.<p></DL>
</DD>
</DL>
<HR>

<A NAME="diffWith(com.versant.fund.HandleVector)"><!-- --></A><H3>
diffWith</H3>
<PRE>
public <A HREF="../../../com/versant/fund/HandleVector.html" title="class in com.versant.fund">HandleVector</A> <B>diffWith</B>(<A HREF="../../../com/versant/fund/HandleVector.html" title="class in com.versant.fund">HandleVector</A>&nbsp;v)</PRE>
<DL>
<DD>Returns a new <code>vector</code> that is the difference of this 
 <code>vector</code> and the <code>vector</code> specified as 
 <code>v</code> and removes empty and duplicate objects from the 
 result.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - The <code>vector</code> to difference with 
                        <code>this</code> <code>vector</code>.<p></DL>
</DD>
</DL>
<HR>

<A NAME="intersectWith(com.versant.fund.HandleVector)"><!-- --></A><H3>
intersectWith</H3>
<PRE>
public <A HREF="../../../com/versant/fund/HandleVector.html" title="class in com.versant.fund">HandleVector</A> <B>intersectWith</B>(<A HREF="../../../com/versant/fund/HandleVector.html" title="class in com.versant.fund">HandleVector</A>&nbsp;v)</PRE>
<DL>
<DD>Returns a new <code>vector</code> that is the intersection of this 
 <code>vector</code> and the <code>vector</code> specified as 
 <code>v</code>.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - The <code>vector</code> to intersect with
                        <code>this</code> <code>vector</code>.
                        Duplicate and null handles are removed from the result.<p></DL>
</DD>
</DL>
<HR>

<A NAME="unionWith(com.versant.fund.HandleVector)"><!-- --></A><H3>
unionWith</H3>
<PRE>
public <A HREF="../../../com/versant/fund/HandleVector.html" title="class in com.versant.fund">HandleVector</A> <B>unionWith</B>(<A HREF="../../../com/versant/fund/HandleVector.html" title="class in com.versant.fund">HandleVector</A>&nbsp;v)</PRE>
<DL>
<DD>Returns a new <code>vector</code> that is the union of this 
 <code>vector</code> and the <code>vector</code> specified as 
 <code>v</code>.
 <p>
 Duplicate and null handles are removed from the result.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - The <code>vector</code> to union with 
                        this vector.</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../com/versant/fund/HandleEnumeration.html" title="interface in com.versant.fund"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../com/versant/fund/NewSessionCapability.html" title="class in com.versant.fund"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?com/versant/fund/HandleVector.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="HandleVector.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
